import { BlobParse, BufferParse, CacheNever, JSONParse, TextParse, headers, parseBinderWithErrorCheck, } from "@pnp/queryable";
import { _SPInstance, SPQueryable } from "../spqueryable.js";
export function StreamParse() {
    return parseBinderWithErrorCheck(async (r) => { var _a; return ({ body: r.body, knownLength: parseInt(((_a = r === null || r === void 0 ? void 0 : r.headers) === null || _a === void 0 ? void 0 : _a.get("content-length")) || "-1", 10) }); });
}
export class ReadableFile extends _SPInstance {
    /**
     * Gets the contents of the file as text. Not supported in batching.
     *
     */
    getText() {
        return this.getParsed(TextParse());
    }
    /**
     * Gets the contents of the file as a blob, does not work in Node.js. Not supported in batching.
     *
     */
    getBlob() {
        return this.getParsed(BlobParse());
    }
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js. Not supported in batching.
     */
    getBuffer() {
        return this.getParsed(BufferParse());
    }
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js. Not supported in batching.
     */
    getJSON() {
        return this.getParsed(JSONParse());
    }
    /**
     * Gets the content of a file as a ReadableStream
     *
     */
    getStream() {
        return SPQueryable(this, "$value").using(StreamParse(), CacheNever())(headers({ "binaryStringResponseBody": "true" }));
    }
    getParsed(parser) {
        return SPQueryable(this, "$value").using(parser, CacheNever())();
    }
}
//# sourceMappingURL=readable-file.js.map